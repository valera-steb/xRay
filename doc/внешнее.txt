где фиксировать проэктные решения?
.имеется в виду, соотносяс с ПФУ, в каком этапе находятся проэктные решения.
.но что есть такое это проэктное решение?
    .имеется в виду с точки зрения ДОТУ.

    .где появляется?
        .в текущем моменте, появилось когда я решил уточнить реализацию treeGenerator-а,
        подмешав в его обязанности пометку состояний и их фильтрацию.

        .при этом, выявилось 2 варианта развития ситуации:
        .1. который был - создать все возможные комбинации:
            .при этом, генератор даёт невалидные состояния - т.е. генерит дальше/лишнее.

            .и по плану/сценарию/алгоритму решения есть этам генерации и есть етап "разбора полётов".
            т.е. анализа сгенеренного графа и его вершин.

        .2. в процессе генерации:
            .выполнять пометку состояний.
            .прерывать погружение в дерево ходов по достижению состояния с пометкой конечное.

            + тут имеется в виду, что каждый ход, порождает свой уровень дерева.
            и делать ход после последнего - выпасть за пределы допустимые.
            эти состояния нас не интерисуют, хотя поле для них есть.

    .другими словами:
        .был выявлен ещё один фактор - возможность добавить ещё одно правило в генератор.
        .исходя из него было выставлено иное целепологание.
        .а вот уже под иные цели - как следствие перестроились сценарий/алгоритмы/распределение ответственностей.

    .т.е.:
        .то, что я подразумевал под проэктным решением было цепочкой из нескольких вещей.
        .и выходит, что это смены разных цепочек....

        .т.е. проэктное решение зафиксированно в цепочке. Просто я этого не заметил.


тогда, как быть с вопросом сравнения нескольких проэктных решений?
!! но ведь целепологание разное
=> как сравнивать разное целепологание?
    .в контексте ситуации / проэкта xRay думаю это возможно сравнить только по финальной целе
    построенному графу - а точнее статическим данным для алгоритма решателя.

    .и лишь по отношению к этой, общей обоим подходам целе, возможно сравнение решений.
    по избранным параметрам:
        .количество операций.
        .занимаемая/требуемая в процессе память.

    + при этом, лишние действия:
        .добавление/удаление невалидных состояний и переходов с ними в граф.
        .либо перепометка состояний (а она вообще возникает во втором варианте?).
    учитываються как раз в оценке количества операций.

    .можно ещё подумать о сложности алгоритма...
        .например простота понимания.

        .но... думаю тесты, какие они сейчас на treeGenerator, каждый маленький аспект описан и разъяснён отдельно,
        достаточно ясно представляют/отображают ситуацию.

        .т.е. ясность понимания алгоритма, "сложения" ответственностей достигать на базе пояснений тестами.
        + да и без тестов я их сложить то ведь не смогу просто.


ошибки внешнего целепологания:
.что я хочу от этих разработок?
    .разве самих разработок?
    + в смысле готовых программ.

    .либо всё-же что-то во мне меняться должно.
    + если так, то на чём должено быть сфокусированно моё внимание?


.культура мышления и психической в целом деятельности
    .а на примерах из жизни это как выглядит?
    + что такое запустило этот разбор - про ошибки?

.почему сейчас, когда я уже вижу цепочку (что есть, какой должен быть результат, алгоритм преобразования)
я разстроен, как только задумываюсь о написании представленной части теряю интерес.


.что внешнее мешает?
    .хотя точнее, что будет после и не даёт мне довести дело до конца?
=>:
    .публикация обсуждение - либо забвение.
    .другое поведение.

+ куда направлена моя активность?
    .ведь за изменением во мне, я стремлюсь и к изменениям в окружающих, обществе.




дописал graphTraveler реализацию с тестами без оптимизаций - в 4-ре функции.
.а что за закономерности/процессы я описываю в аи?
    .процесс нахождения частной меры по набору правил?


.а что за закономерность/процесс я подметил в разработке?
    .есть общая многогранная задача, которую решаю.
    .есть грани, которые ухватил - могу описать имеющимся набором "базовых" средств.
    .провожу описание со "стабилизацией" версии.
    .далее:
        .либо соотношу описания между собой - "сплетаю грани"
        .либо пердудущий уровень становиться фундаментом для следующего.
        .либо берусь за следующий кусочек - часть фундамента для более общего
            + предполагая, что этих частей выделенных отдельно - несколько.

+ а как подмеченный процесс сотносится с требованием проэктировать "сверху в низ"?
    .от общего к частному?

=> а могу ли я увидить это общее изначально?
    + и даже если да - а могу ли описать?
    + и если могу описать - а что оно мне даст?
        .а точнее, как его зафиксировать?
        !.что этим описанием я могу зафиксировать?

        + но и как его фиксировать - тесты, последовательности вызовов фэйков.





стараюсь вернуться к проэкту, после отхода в сторону на осознание ещё одного подхода.
.и тут вопрос:
    .новый подход применять ли тут?
        .если да, то где?
    .а разве я его не применял в другом виде?
        .имеется в виду применял к себе в текстовом виде, но не воплощал в код
        .код оказывался результатом воплощения и исключительно исполнительными частями - оу.
    .



странное ощущение:
.после вопроса выше, я решил дописать алгоритм пометки вершины.
.расписал что уже есть, потом признаки пометки, и потом 2 примечания.
.и что я почувствовал?
    .алгоритм для кодирования сложился, я могу его написать, к тому-же он тривиальный.
    ¿матрица собралась?
    .либо концепция довыражена - вскрыто достаточно закономерностей предметной области что-бы на базе освоенных мною умений подходов и выразительных возможностей js + дописанного мной кода передать эти закономерности в коде?



вот этот процесс разкрытия алгоритма.
.когда в начале я зафиксировал требования и уже существующие вещи.
.потом сделал первый набросок в словах что делать надо по частям.
.оно чуть полежало, и дальше я заметил что не хватает промежуточной структуры-карты.
.выставил требование к карте и уточнил поток данных - что частям надо что-бы выполнить свои функции.
.и после этого взялся каждую часть описывать в коде, паралельно набрасывая тесты на неё.

и тут:
.вроде первые 2 части - так вообще 2+2 - простые алгоритмы (getOuterMaps и groupByPrognosis)
.только 2 следующих части (функции) оказались посложнее а точнее более предметно ориентированными
    .но и они не составили труда для тестирования и описания.
    .хотя для последней (separate) всё-же пришлось схитрить с большим набором данных тестовых.

и вот:
.осознание этого процесса.
.ощущение - на уровне эмоций и чувств - его меня интерисует.
.определение настроения ему подходящего, его порождающего и его удерживающего.
.осознание его характеристик - за чем и как наблюдать, и способов влияния на него.
вот что изучить теперь надо.














