есть:
    .карта ходов.
        .в ходах есть проходы к некорректным ходам.
        .нужно убрать ходы к лишним...
    .набор пометок.

вывод:
    .достаточно собрать пометки и карту - получить ещё одну карту.
    .нет - нужно отследить начиная с конца карты пути:
        .если в точку приходят из как минимум 2-х разных позиций
            .пометка неопределённо.
        .только из одной - от этой одной.

    .превратить в:
        {
            '00x000000': [{t:_num_, m:'_mark_'}, ...]
        }
    + оставить - ид к ключу_состоянию:
        {
            1: '00x000000',
            2: '00xy00000'
        }


решение:
    .найти все конечные состояния - у них нету выходов.
        .они становяться начальными состояниями, от которых идёт построение.

    .перебрать все активные, в зависимости от пометки:
        .не перемещать.
        .скопировать

+ а зачем?
    .зачем мне в начале строить матрицу с невалидными состояниями.
    .а потом их отыскивать и очищать?


тогда, получиться что я могу сгенерить только валидные состояния.
и останеться задача сделать пометки?

но ведь я и так проверяю состояния перед добавлением.
другими словами - можно сразу при генерации добавлять пометки
=> генератор возвращать должен:
    {
        idToKey: {...},
        keys: {
            '00x000000': {i: 3, t:[5, 6], f:[1], m:'_mark_' },
            '00xy00000': {i: 13, t:[...], f:[...], m:'_mark_' }
        }
    }


в итоге мне нужен обратный обход.
но можно проще - нужен ещё один stateMarker
  однако принимающий решение на основе предудущих состояний
  и обходящий с конца в начало



!!! обратный проход по направленному графу, с условиями:
  .есть набор конечных состояний.
  .в состояние попадаем только если все предудущие уже пройдены.


что дальше?
.а что есть?
    .переделанный treeGenerator - теперь выдаёт только допустимые состояния, сразу с пометками.
.выходит, мне нужен преобразователь... либо извлекатель... обходчик графа - от последних состояний к первым.
    .при этом с ограничением - заходим в предыдущее только когда все последующие уже посетили.


а как выглядит конечная цель ai?
{
    idToKey: {
        1: '000 000 000',
        2: '000 0x0 000',
        ...
        1n: '000 xx0 yy0',
        2n: '000 xxx yy0',
        3n: 'x00 xx0 yy0'
    },
    keys: {
        '000 000 000': {w:[], f:[], n:[2, ...]},
        ...
        '000 xx0 yy0': {w:[2n] f:[3n], n:[]}
        ...
        '000 xxx yy0': {winner:'x'},
        ...
        '0x0 x0x yyy': {winner: 'y'},
        ...
        'xyx yxy yxy': {winner: 'no'}
    }
}





дописал graphTraveler

и что нужно делать при наличии такого рода обхода графа?
=> получать результирующий объект.
    .в момент попадания вершины в обход, все предыдущие уже посещены.
    .в этот момент её надо добавить в результат.
    .а точнее, данные из неё уже можно разбить как требовалось и перенести в результирующий объект.

    + при этом в графе исходном можно добавить свою особую пометку, p(rognoze):
        .выигрыш одного.
        .ничья.
        .к выирышу.
        .к проигрышу.
        .к ничьей.
        .в промежуточное состояние.


¿.добавить ui который будет принимать выстроенный граф - цель ai - и добавлять "ходилку" по нему?






алгоритм построения размеченного графа.
.есть:
    .граф всех ходов с пометками состояний.
    .алгоритм обратного обхода - т.е. последовательно выдаёт набор вершин начиная с конечных и продолжает "новыми конечными", появившимися после вычёркивания пройденных.

.т.е. в принимающую функцию будут попадать вершины у которых:
    .нет предшественников, и тогда у такой вершины состояние: ничья, выигрыш одного, выигрыш другого.
    .либо есть набор вершин предшественников. И тогда пометка текущей вершины в зависимости от попавшей:
        .к выигрышу одного - если есть выход только в выигрых одного 
            (возможно в несколько выигрышных вершин).
        .к выигрышу другого - если есть выход только к выигрышу другого.
        .к ничьей - ... выход только к ничьей.
        .в промежуточное состояние, если есть выходы в несколько разных пометок:
            .ничьей, выигрушу одного, выигрышу другого, промежуточное.

.при этом:
    .уже пройденные вершины ищем в результирующем графе, и берём их пометки.
    .после пометки текущей вершины, добавляем её в результирующий граф.

+ части:
    .функция пометки.
    .по вершинам извлечь пары ид-пометка.
    .группировка ид-шек по пометкам.
    .цикл перебора:
        .получить вершину,
        .для последующих вершин получить массив из ид-пометка из карты,
        .пометить текущую,
        .вставить текущую вершину в результат и карту.

    .карта
        {
            'xxx yy0 000': { id: 12, p: 'winner x'},
            'xx0 yyx xyy': { id: 11, p: 'to x' },
            'x00 yy0 000': { id: 10, p: 'middle' }
        }

.название:
    .graphSeparator -
    .gameGraphBuilder
    .идея - граф у которого выходы сгруппированы по направлениям к результатам игры.




